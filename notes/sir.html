<!doctype html>
<html lang=en>
<head>
<style type="text/css">
.inline {
  background-color: #f7f7f7;
  border:solid 1px #B0B0B0;
}
.error {
	font-weight: bold;
	color: #FF0000;
}
.warning {
	font-weight: bold;
}
.message {
	font-style: italic;
}
.source, .output, .warning, .error, .message {
	padding: 0 1em;
  border:solid 1px #F7F7F7;
}
.source {
  background-color: #f5f5f5;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.center {
  text-align: center;
}
.hl.num {
  color: #AF0F91;
}
.hl.str {
  color: #317ECC;
}
.hl.com {
  color: #AD95AF;
  font-style: italic;
}
.hl.opt {
  color: #000000;
}
.hl.std {
  color: #585858;
}
.hl.kwa {
  color: #295F94;
  font-weight: bold;
}
.hl.kwb {
  color: #B05A65;
}
.hl.kwc {
  color: #55aa55;
}
.hl.kwd {
  color: #BC5A65;
  font-weight: bold;
}
</style>
<meta charset=utf-8>
<title>Stefan Siegert</title>
<link rel=stylesheet href=/style.css>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<h1><a href=/ title="Stefan Siegert">Stefan Siegert</a></h1>


<h2>A simple agent-based model implemented in base R</h2>

<p>This note goes over a simple agent based model of infectious disease spread written in base R.

<p>I do realise I'm about 5 years late to write about agent-based modelling for disease spread, but that's fine.

<p>I was first looking at ABM frameworks such as NetLogo and Mesa, but kept running into annoying installation problems. I realised the simple model I wanted to code up doesn't really need a framework, and so wrote it quickly in base R. 

<p>I assume I have a large-ish number of agents that move around randomly within a bounded domain. Initially one agent is infected with a disease, and all others are susceptible to being infected. Whenever a susceptible agent gets close to the infected one, it also becomes infected with some probability. If an agent becomes infected, it can pass the disease on to other susceptible agents that it gets close to. After being infected for some time, the infected agent recovers. It is now not infectious anymore, and also cannot become infected again.

<p>The full R script can be downloaded here: <a href='sir.R'>sir.R</a>. No external libraries are required. 

<p>Here is the visualisation of the final result. Blue is susceptible, red is infected, and green is recovered.</p>

<img src="fig/sir.gif">


<p>I first assign all model parameters within an empty list called "agents"

<div class="chunk" id="unnamed-chunk-1"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl com"># initiliase list of model parameters</span>
<span class="hl std">agents</span> <span class="hl kwb">=</span> <span class="hl kwd">within</span><span class="hl std">(</span><span class="hl kwd">list</span><span class="hl std">(), {</span>
  <span class="hl std">n_agents</span> <span class="hl kwb">=</span> <span class="hl num">1000</span>  <span class="hl com"># number of agents</span>
  <span class="hl std">p_inf</span> <span class="hl kwb">=</span> <span class="hl num">0.5</span>      <span class="hl com"># probability of infection on contact</span>
  <span class="hl std">r_inf</span> <span class="hl kwb">=</span> <span class="hl num">0.02</span>     <span class="hl com"># radius that defines &quot;contact&quot;, as fraction of domain width</span>
  <span class="hl std">t_rec</span> <span class="hl kwb">=</span> <span class="hl num">20</span>       <span class="hl com"># time to recovery</span>
  <span class="hl std">w_step</span> <span class="hl kwb">=</span> <span class="hl num">0.02</span>    <span class="hl com"># maximum step width in each direction, as fraction of domain width</span>
<span class="hl std">})</span>
</pre></div>
</div></div>

<p>Using "within(list(), ..." instead of "list(...)" here isn't really necessary, but it makes explicit that I'm using "agents" as an environment within which the agents' state will be stored and manipulated.

<p>Then, within "agents" I randomly initialise x and y locations of all agents, by sampling uniformly on the unit interval. The agents' current states are stored in a vector, where 0 indicates susceptible, 1 indicates infected, and 2 indicates recovered. Infection times are stored in a separate vector, initially as NA for susceptible agents. Upon infection, the time is set to recovery time, and will be decreased by one on each simulation step. I also initialise a history object in which I store the fraction of susceptible, infected and recovered agents over time.

<div class="chunk" id="unnamed-chunk-2"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl com"># initialise state variables (agent coordinates, infection state, infection</span>
<span class="hl com"># time). initially, just one agent at the center is infected.</span>
<span class="hl std">agents</span> <span class="hl kwb">=</span> <span class="hl kwd">within</span><span class="hl std">(agents, {</span>
  <span class="hl com"># initial locations are uniformly distributed</span>
  <span class="hl std">xy</span> <span class="hl kwb">=</span> <span class="hl kwd">cbind</span><span class="hl std">(</span><span class="hl kwd">runif</span><span class="hl std">(n_agents),</span> <span class="hl kwd">runif</span><span class="hl std">(n_agents))</span>
  <span class="hl com"># at first, all are susceptible (state = 0)</span>
  <span class="hl std">state</span> <span class="hl kwb">=</span> <span class="hl kwd">rep</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">, n_agents)</span>
  <span class="hl std">time</span> <span class="hl kwb">=</span> <span class="hl kwd">rep</span><span class="hl std">(</span><span class="hl num">NA</span><span class="hl std">, n_agents)</span>
  <span class="hl com"># i=1 is patient zero located at center</span>
  <span class="hl std">xy[</span><span class="hl num">1</span><span class="hl std">, ]</span> <span class="hl kwb">=</span> <span class="hl kwd">c</span><span class="hl std">(</span><span class="hl num">0.5</span><span class="hl std">,</span> <span class="hl num">0.5</span><span class="hl std">)</span>
  <span class="hl std">state[</span><span class="hl num">1</span><span class="hl std">]</span> <span class="hl kwb">=</span> <span class="hl num">1</span>
  <span class="hl std">time[</span><span class="hl num">1</span><span class="hl std">]</span> <span class="hl kwb">=</span> <span class="hl std">t_rec</span>
  <span class="hl com"># initialise history object</span>
  <span class="hl std">history</span> <span class="hl kwb">=</span> <span class="hl kwd">matrix</span><span class="hl std">(</span><span class="hl kwc">nrow</span><span class="hl std">=</span><span class="hl num">0</span><span class="hl std">,</span> <span class="hl kwc">ncol</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">)</span>
<span class="hl std">})</span>
</pre></div>
</div></div>

<p>Now for the updating function which steps the agents forward in time. In each step, agents move around by adding a small random number with mean zero to their x and y coordinates. To determine whether agents are in contact, I calculate all pairwise distances between agents and look for pairs whose distance is below a certain threshold. If an agent is infected (has state 1) then all of its neighbors that are susceptible (have state 0) randomly change their state from 0 to 1 with the given infection probability. Recovery times are decreased by one, and newly infected agents get their recovery time initialised. Agent whose recovery time reached zero get their state set to 2 for recovered. And we also append the current state to the history object.

<div class="chunk" id="unnamed-chunk-3"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl com"># agent updating function (move, infect, recover)</span>
<span class="hl std">update</span> <span class="hl kwb">=</span> <span class="hl kwa">function</span><span class="hl std">(</span><span class="hl kwc">agents</span><span class="hl std">)</span> <span class="hl kwd">within</span><span class="hl std">(agents, {</span>
  <span class="hl com">#</span>
  <span class="hl com"># move agents randomly, ensure they don't leave the domain</span>
  <span class="hl std">rand_step</span> <span class="hl kwb">=</span> <span class="hl kwd">matrix</span><span class="hl std">(</span><span class="hl kwd">runif</span><span class="hl std">(</span><span class="hl num">2</span><span class="hl opt">*</span><span class="hl std">n_agents,</span> <span class="hl opt">-</span><span class="hl std">w_step, w_step),</span> <span class="hl kwc">ncol</span><span class="hl std">=</span><span class="hl num">2</span><span class="hl std">)</span>
  <span class="hl std">xy</span> <span class="hl kwb">=</span> <span class="hl kwd">pmax</span><span class="hl std">(</span><span class="hl kwd">pmin</span><span class="hl std">(xy</span> <span class="hl opt">+</span> <span class="hl std">rand_step,</span> <span class="hl num">1</span><span class="hl std">),</span> <span class="hl num">0</span><span class="hl std">)</span>
  <span class="hl com"># </span>
  <span class="hl com"># calculate all pairwise distances and identify neighbors</span>
  <span class="hl std">distmat</span> <span class="hl kwb">=</span> <span class="hl kwd">as.matrix</span><span class="hl std">(</span><span class="hl kwd">dist</span><span class="hl std">(xy))</span>
  <span class="hl kwd">diag</span><span class="hl std">(distmat)</span> <span class="hl kwb">=</span> <span class="hl num">Inf</span> <span class="hl com"># to exclude self from neighbors</span>
  <span class="hl std">neighbors</span> <span class="hl kwb">=</span> <span class="hl kwd">which</span><span class="hl std">(distmat</span> <span class="hl opt">&lt;=</span> <span class="hl std">r_inf,</span> <span class="hl kwc">arr.ind</span> <span class="hl std">=</span> <span class="hl num">TRUE</span><span class="hl std">)</span>
  <span class="hl com"># randomly infect susceptible neighbors</span>
  <span class="hl kwa">for</span> <span class="hl std">(ii</span> <span class="hl kwa">in</span> <span class="hl kwd">seq_len</span><span class="hl std">(</span><span class="hl kwd">nrow</span><span class="hl std">(neighbors))) {</span>
    <span class="hl std">i_from</span> <span class="hl kwb">=</span> <span class="hl std">neighbors[ii,</span> <span class="hl num">1</span><span class="hl std">]</span>
    <span class="hl std">i_to</span> <span class="hl kwb">=</span> <span class="hl std">neighbors[ii,</span> <span class="hl num">2</span><span class="hl std">]</span>
    <span class="hl kwa">if</span> <span class="hl std">(state[i_from]</span> <span class="hl opt">==</span> <span class="hl num">1</span> <span class="hl opt">&amp;</span> <span class="hl std">state[i_to]</span> <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl std">) {</span>
      <span class="hl std">state[i_to]</span> <span class="hl kwb">=</span> <span class="hl kwd">ifelse</span><span class="hl std">(</span><span class="hl kwd">runif</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl std">)</span> <span class="hl opt">&lt;</span> <span class="hl std">p_inf,</span> <span class="hl num">1</span><span class="hl std">,</span> <span class="hl num">0</span><span class="hl std">)</span>
    <span class="hl std">}</span>
  <span class="hl std">}</span>
  <span class="hl com">#</span>
  <span class="hl com"># decrement recovery time of infected, initialise recovery time of newly</span>
  <span class="hl com"># infected, and recover agents where recovery time is zero</span>
  <span class="hl std">time</span> <span class="hl kwb">=</span> <span class="hl kwd">pmax</span><span class="hl std">(time</span> <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl std">,</span> <span class="hl num">0</span><span class="hl std">)</span>
  <span class="hl std">time[</span> <span class="hl kwd">is.na</span><span class="hl std">(time)</span> <span class="hl opt">&amp;</span> <span class="hl std">state</span> <span class="hl opt">==</span> <span class="hl num">1</span> <span class="hl std">]</span> <span class="hl kwb">=</span> <span class="hl std">t_rec</span>
  <span class="hl std">state[ time</span> <span class="hl opt">==</span> <span class="hl num">0</span> <span class="hl std">]</span> <span class="hl kwb">=</span> <span class="hl num">2</span>
  <span class="hl com"># update history</span>
  <span class="hl std">new_row</span> <span class="hl kwb">=</span> <span class="hl kwd">c</span><span class="hl std">(</span><span class="hl kwc">s</span><span class="hl std">=</span><span class="hl kwd">mean</span><span class="hl std">(state</span><span class="hl opt">==</span><span class="hl num">0</span><span class="hl std">),</span> <span class="hl kwc">i</span><span class="hl std">=</span><span class="hl kwd">mean</span><span class="hl std">(state</span><span class="hl opt">==</span><span class="hl num">1</span><span class="hl std">),</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl kwd">mean</span><span class="hl std">(state</span><span class="hl opt">==</span><span class="hl num">2</span><span class="hl std">))</span>
  <span class="hl std">history</span> <span class="hl kwb">=</span> <span class="hl kwd">rbind</span><span class="hl std">(history, new_row,</span> <span class="hl kwc">deparse.level</span><span class="hl std">=</span><span class="hl num">0</span><span class="hl std">)</span>
<span class="hl std">})</span>
</pre></div>
</div></div>

<p>Visualisation is optional, but fun. The visualise function produces a plot of agents positions with their state color coded. And it produces a second plot showing the history.

<div class="chunk" id="unnamed-chunk-4"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl com"># visualisation function: scatter plot of agents and time series of SIR</span>
<span class="hl com"># history. use dev.hold and dev.flush to avoid flickering plots.</span>
<span class="hl std">visualise</span> <span class="hl kwb">=</span> <span class="hl kwa">function</span><span class="hl std">(</span><span class="hl kwc">agents</span><span class="hl std">)</span> <span class="hl kwd">with</span><span class="hl std">(agents, {</span>
  <span class="hl kwd">dev.hold</span><span class="hl std">()</span>
  <span class="hl kwd">layout</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl kwd">rep</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl std">,</span><span class="hl num">3</span><span class="hl std">),</span> <span class="hl num">2</span><span class="hl std">))</span>
  <span class="hl com"># plot agents</span>
  <span class="hl kwd">par</span><span class="hl std">(</span><span class="hl kwc">mar</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">,</span><span class="hl num">0</span><span class="hl std">,</span><span class="hl num">0</span><span class="hl std">,</span><span class="hl num">0</span><span class="hl std">))</span>
  <span class="hl kwd">plot</span><span class="hl std">(xy,</span> <span class="hl kwc">col</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">'blue'</span><span class="hl std">,</span><span class="hl str">'red'</span><span class="hl std">,</span><span class="hl str">'green'</span><span class="hl std">)[state</span><span class="hl opt">+</span><span class="hl num">1</span><span class="hl std">],</span>
       <span class="hl kwc">pch</span> <span class="hl std">=</span> <span class="hl num">16</span><span class="hl std">,</span> <span class="hl kwc">ann</span><span class="hl std">=</span><span class="hl num">FALSE</span><span class="hl std">,</span> <span class="hl kwc">axes</span><span class="hl std">=</span><span class="hl num">FALSE</span><span class="hl std">,</span> <span class="hl kwc">asp</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl std">,</span>
       <span class="hl kwc">xlim</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">,</span><span class="hl num">1</span><span class="hl std">),</span> <span class="hl kwc">ylim</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">,</span><span class="hl num">1</span><span class="hl std">))</span>
  <span class="hl com"># plot history</span>
  <span class="hl kwd">par</span><span class="hl std">(</span><span class="hl kwc">mar</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl num">3</span><span class="hl std">,</span><span class="hl num">3</span><span class="hl std">,</span><span class="hl num">3</span><span class="hl std">,</span><span class="hl num">3</span><span class="hl std">))</span>
  <span class="hl kwd">matplot</span><span class="hl std">(history,</span> <span class="hl kwc">type</span><span class="hl std">=</span><span class="hl str">'l'</span><span class="hl std">,</span> <span class="hl kwc">las</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl std">,</span>
          <span class="hl kwc">col</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">'blue'</span><span class="hl std">,</span><span class="hl str">'red'</span><span class="hl std">,</span><span class="hl str">'green'</span><span class="hl std">),</span> <span class="hl kwc">lty</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl kwc">ylim</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">,</span><span class="hl num">1</span><span class="hl std">),</span>
          <span class="hl kwc">main</span> <span class="hl std">=</span> <span class="hl kwd">paste</span><span class="hl std">(</span><span class="hl kwd">tail</span><span class="hl std">(history,</span> <span class="hl num">1</span><span class="hl std">),</span> <span class="hl kwc">collapse</span><span class="hl std">=</span><span class="hl str">'|'</span><span class="hl std">))</span>
  <span class="hl kwd">dev.flush</span><span class="hl std">()</span>
<span class="hl std">})</span>
</pre></div>
</div></div>

<p>With the agents object intialised and the update and visualise functions defined, we can repeatedly update the agents state in a loop and visualise them in each step. We monitor the history and stop the simulation when nothing changes over a number of steps. 

<div class="chunk" id="unnamed-chunk-5"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl com"># main loop: simulate, visualise, check for stopping condition</span>
<span class="hl kwa">while</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl std">) {</span>
  <span class="hl std">agents</span> <span class="hl kwb">=</span> <span class="hl kwd">update</span><span class="hl std">(agents)</span>
  <span class="hl kwd">visualise</span><span class="hl std">(agents)</span>
  <span class="hl com"># stop if state doesn't vary for 50 timesteps</span>
  <span class="hl std">past</span> <span class="hl kwb">=</span> <span class="hl kwd">tail</span><span class="hl std">(agents</span><span class="hl opt">$</span><span class="hl std">history,</span> <span class="hl num">50</span><span class="hl std">)</span>
  <span class="hl std">var_past</span> <span class="hl kwb">=</span> <span class="hl kwd">apply</span><span class="hl std">(past,</span> <span class="hl num">2</span><span class="hl std">, var)</span>
  <span class="hl kwa">if</span> <span class="hl std">(</span><span class="hl kwd">nrow</span><span class="hl std">(past)</span> <span class="hl opt">==</span> <span class="hl num">50</span> <span class="hl opt">&amp;&amp;</span> <span class="hl kwd">all</span><span class="hl std">(var_past</span> <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl std">)) {</span>
    <span class="hl kwa">break</span>
  <span class="hl std">}</span>
<span class="hl std">}</span>
</pre></div>
</div></div>


<p>ABM frameworks are usually implemented using object oriented frameworks. This is because each agent has a state which constantly changes based on its own state and that of other agents. I first considered using one of R's formal OOP frameworks, but the model is simple enough to store the state of all agents within a list that contains model parameters, locations, infection state, etc, and run the time stepping code inside that list using the "within" function.

<p>Apart from being coded in base R, the main bottleneck of the code is currently that I calculate distances between all pairs of agents to determine neighborhood. To make this more efficient, I could calculate only distances for infected agents. But that's for another day.










